# Regras do Projeto - ChinaFacil NestJS

## Contexto do Projeto
Este é um projeto backend construído com NestJS (Node.js framework). A estrutura segue o padrão modular do NestJS onde cada feature possui seu próprio módulo, controller, service e DTOs. Utilizamos TypeScript para type safety e Prisma como ORM para gerenciamento do banco de dados.

## Regras de Código

### Estilo e Qualidade
- NUNCA crie comentários no código. O código deve ser autoexplicativo através de nomes semânticos.
- Use nomes de variáveis, funções, classes e métodos SEMÂNTICOS e descritivos que expressem claramente sua intenção.
- EVITE nomes genéricos como `data`, `item`, `temp`, `handler`, `process`, `manager`. Seja específico: `userData`, `productItem`, `userSession`, `createUserHandler`, `processPayment`, `emailManager`.
- Prefira funções e métodos pequenos com responsabilidade única (Single Responsibility Principle).

### NestJS - Boas Práticas
- Siga a arquitetura modular do NestJS: cada feature em seu próprio módulo.
- Controllers devem apenas orquestrar requisições e respostas, delegando lógica para Services.
- Services contêm a lógica de negócio.
- Use DTOs (Data Transfer Objects) para validação de entrada com class-validator.
- Use decorators do NestJS adequadamente (@Injectable, @Controller, @Get, @Post, etc).
- Implemente tratamento de exceções usando HttpException ou exceções personalizadas do NestJS.
- Use Dependency Injection corretamente através do constructor.

### TypeScript
- Sempre use tipagem explícita. Evite `any`.
- Use interfaces ou types para estruturas de dados complexas.
- Aproveite recursos avançados do TypeScript quando apropriado (generics, utility types, etc).

### Testes
- NÃO crie testes unitários por padrão. Somente se for EXPLICITAMENTE solicitado teste unitário.
- O padrão é criar testes de INTEGRAÇÃO simples.
- Use Jest e Supertest para testes de integração.
- **SEMPRE execute testes em modo single thread** para evitar sobrecarga do sistema. Use `--runInBand` ou `--maxWorkers=1`:
  - `npm test -- --runInBand`
  - `npm run test:int -- --runInBand`
  - NUNCA execute testes em paralelo sem este flag.

### Regras de Testes de Integração por Endpoint

**Quantidade de testes por endpoint:**
- MÍNIMO: 2 testes por endpoint
- MÁXIMO: 4 testes por endpoint

**Estrutura obrigatória dos testes:**
1. **Teste de Sucesso** (obrigatório): Valida que o endpoint funciona corretamente com payload válido
2. **Teste de Bad Request** (obrigatório): Valida erro 400 quando payload é inválido ou incompleto
3. **Teste de Middleware** (apenas se existir middleware): Um teste para cada middleware, validando erro de autorização (401/403)

**Regras de quantidade:**
- Endpoint SEM middleware: exatamente 2 testes (sucesso + bad request)
- Endpoint COM 1 middleware: 3 testes (sucesso + bad request + 401)
- Endpoint COM 2+ middlewares: até 4 testes (sucesso + bad request + até 2 testes de middleware)

**Regras de implementação:**
- EVITE métodos de teste com mais de 10 linhas de código
- Validar apenas campos principais da resposta, não toda a estrutura

**⚠️ REGRA CRÍTICA - STATUS CODE ÚNICO:**
- Cada teste DEVE validar EXATAMENTE UM status code
- Use SEMPRE `expect(res.status).toBe(XXX)` com um único valor
- PROIBIDO usar arrays de status: `expect([200, 400, 500]).toContain(res.status)` ❌
- PROIBIDO aceitar "qualquer sucesso": `expect(res.status).toBeLessThan(400)` ❌
- Se o endpoint pode retornar diferentes status em cenários diferentes, crie TESTES SEPARADOS para cada cenário

**Status codes esperados por tipo de teste:**
- Teste de sucesso GET: `expect(res.status).toBe(200)`
- Teste de sucesso POST: `expect(res.status).toBe(201)`
- Teste de sucesso DELETE/PATCH/PUT: `expect(res.status).toBe(200)`
- Teste de bad request: `expect(res.status).toBe(400)`
- Teste sem autenticação: `expect(res.status).toBe(401)`
- Teste sem permissão: `expect(res.status).toBe(403)`
- Teste recurso não encontrado: `expect(res.status).toBe(404)`

**Exemplo CORRETO:**
```typescript
it("should create user successfully", async () => {
  const res = await ctx.authReq.post("/api/users").send(validPayload);
  expect(res.status).toBe(201);
});
```

**Exemplo ERRADO (NUNCA FAÇA ISSO):**
```typescript
it("should search products", async () => {
  const res = await ctx.req.get("/api/products/search?q=test");
  expect([200, 500, 503]).toContain(res.status); // ❌ PROIBIDO
});
```

### Banco de Dados (Prisma)
- Nomes de tabelas em snake_case (exemplo: `user_profiles`, `order_items`).
- Nomes de campos no Prisma em camelCase (exemplo: `userId`, `createdAt`).
- Use `@map` para mapear campos camelCase para snake_case no banco quando necessário.
- Sempre defina relacionamentos bidirecionais quando aplicável.
- Use tipos apropriados e constraints (unique, default, etc).

